        var matchFips;

        // Finish later & check with documentation
        var sectionNames = {
            sviUninsuredPercentile: ["sviUninsuredPercent","Uninsured","Insured"],
            sviMinorityPercentile: ["sviMinorityPercent","Minority","Not Minority"],
            sviPovertyPercentile: ["sviPovertyPercent","In Poverty","Not In Poverty"],
            sviUnemploymentRatePercentile: ["sviUnemploymentRate","Unemployed","Employed"],
            sviNoHighSchoolPercentile: ["sviNoHighSchoolPercent","No High School","Completed High School"],
            sviEnglishLackingPercentile: ["sviEnglishLackingPercent","English Lacking","English Not Lacking"],
            sviMobileHousingPercentile: ["sviMobileHousingPercent","Mobile Housing","Not Mobile Housing"],
            sviDisabledPercentile: ["sviDisabledPercent","Disabled","Not Disabled"],
            sviCrowdingPercentile: ["sviCrowdingPercent","Crowding","No Crowding"],
            sviNoVehiclePercentile: ["sviNoVehiclePercent","No Vehicle","Owns Vehicle"],
            sviInstitutionalizedGroupQuartersPercentile: ["sviInstitutionalizedGroupQuartersPercent","Institutionalized","Not Institutionalized"],
            sviAge65OverPercentile: ["sviAge65OverPercent","Age >= 65", "Age < 65"],
            sviAge17UnderPercentile: ["sviAge17UnderPercent","Age <= 17","Age > 17"],
            sviSingleParentPercentile: ["sviSingleParentPercent","Single Parent","Both Parents"],
            sviUninsuredPercent: ["sviUninsuredPercent","Uninsured","Insured"],
        };

        var selected = [];
        var selected_index = 0;
        
        function loadAxes(){
          var x = [sviVariables[currentSviLayer].name];
          var y = [covidVariables[currentCovidLayer].name];
          selected = [];
          selected_index = 0;

          var i;
          for (i = 0; i < geoJSON.features.length; i++) {
            
            y.push(parseFloat(geoJSON.features[i].properties[currentCovidLayer]));
            
            if (geoJSON.features[i].properties[currentSviLayer] < 0){
              x.push(0);
            }else{
              x.push(geoJSON.features[i].properties[currentSviLayer]);
            }
            
            if (matchFips == geoJSON.features[i].properties.fipsSvi){
              selected_index = i;
              selected.push(geoJSON.features[i].properties[currentSviLayer]);
              selected.push(geoJSON.features[i].properties[currentCovidLayer]);
            }
          }
          //console.log(x);
          return [x,y,selected];
        }
        

        function loadSections(){
          let colPos = [sectionNames[currentSviLayer][1]];
          let colNeg = [sectionNames[currentSviLayer][2]];
          
          let percentEquivalentLayer = sectionNames[currentSviLayer][0];

          let i;
          for (i = 0; i < geoJSON.features.length; i++) {
            if (matchFips == geoJSON.features[i].properties.fipsSvi){
              colPos.push(geoJSON.features[i].properties[percentEquivalentLayer]);
              colNeg.push(100 - geoJSON.features[i].properties[percentEquivalentLayer]);
            }
          }
          return ([colPos,colNeg]);
        }

        function loadMaskCats(){
          var never = ["Never"];
          var rarely = ["Rarely"];
          var sometimes = ["Sometimes"];
          var frequently = ["Frequently"];
          var always = ["Always"];

          var i;
          for (i = 0; i < geoJSON.features.length; i++) {
            if (matchFips == geoJSON.features[i].properties.fipsSvi){
              never.push(geoJSON.features[i].properties.maskNever);
              rarely.push(geoJSON.features[i].properties.maskRarely);
              sometimes.push(geoJSON.features[i].properties.maskSometimes);
              frequently.push(geoJSON.features[i].properties.maskFrequently);
              always.push(geoJSON.features[i].properties.maskAlways);
            }
          }
          return ([never,rarely,sometimes,frequently,always]);
        }

      
        
        function createScatterplot(axes){
            
            var scatterplot;
            var yLabel = axes[1][0];
            var xLabel = axes[0][0];
            axes[1][0] = "yAxis";
            axes[0][0] = "xAxis";
            
            let yTrend = createTrendAxis(axes[0],axes[1]).slice(0,3);
            //console.log(axes)
            //console.log(yTrend)
      
            scatterplot = c3.generate({
                  bindto:'#scatterplot',
                  data: {
                      xs: {
                          yAxis: 'xAxis',
                          yTrend: 'xTrend',
                          yHighlight: 'xHighlight'
                      },
                      columns: [
                          axes[0],
                          axes[1],
                          yTrend,
                          ['xTrend',Math.min(...axes[0].slice(1)),Math.max(...axes[0].slice(1))],
                          ['yHighlight',axes[2][1]],
                          ['xHighlight',axes[2][0]],
                      ],
                      types: {
                        yAxis: 'scatter',
                        yTrend: 'line',
                        yHighlight: 'scatter'
                      },
                      color: function(color,d) {
                            // if this is the trend line
                            if (d.id == 'yTrend') {
                              return '#A573F0';
                            }
                            // if this is a datapoint
                            if (d.id == 'yHighlight'){
                              return '#52307C';
                            }else{
                              return '#CCCCCC';
                            }
                          },
                      onclick: function (d, element) {
                        if (d.x == selected[0]) {
                          // dont need to do anything if its already the selected element!
                        } else {
                          //console.log(d);
                          //console.log(`A non-selected element was clicked. The index is ${d.index} and the corresponding county name of that index is ${geoJSON.features[d.index].properties.countyName}. Its FIPS is ${geoJSON.features[d.index].properties.fipsSvi}`)
                          onMapClick(geoJSONSortedBySvi[d.index],1);
                          // center selected county on map
                          map.flyTo({
                            center: geoJSONSortedBySvi[d.index].geometry.coordinates[0][0],
                            speed: 0.7,
                            essential: true // this animation is considered essential with respect to prefers-reduced-motion
                          });
                          
                          /*console.log("c3js says that the index is "+index);
                          for (let i = 0; i < geoJSON.features.length; i++) {
                            if (parseFloat(x) == geoJSON.features[i].properties[currentSviLayer]) {
                              console.log(".. but its actually "+i+"!!!!");
                            }*/
                        }
                        
                      }
                  },
                  order: false,
                  axis: {
                      x: {
                          label: xLabel,
                          tick: {
                              fit: false
                          }
                      },
                      y: {
                          label: yLabel,
                          tick: {
                              fit: true
                          }
                      }
                  },
                  point: {
                    r: function(d) {
                       if (d.id == 'yHighlight'){
                         return 10;
                       } else{
                         return 3;
                       }
                    },
                    show: function(d) {
                      if (d.id == 'yTrend') {
                        return false;
                      }
                    },
                    focus: {
                      expand: {
                        enabled: false
                      }
                    }
                  },
                  zoom: {
                     enabled: true,
                     rescale: true
                  },   
                  interaction: {
                    enabled: true
                  },
                  tooltip: {
                    format: {
                      title: function (x, index) { 
                        if (x == selected[0]) {
                          //console.log("Selected Point!");
                          return geoJSON.features[selected_index].properties.countyName + ', ' + geoJSON.features[selected_index].properties.stateAbbrev;
                        } else {
                          /*console.log("c3js says that the index is "+index);
                          for (let i = 0; i < geoJSON.features.length; i++) {
                            if (parseFloat(x) == geoJSON.features[i].properties[currentSviLayer]) {
                              console.log(".. but its actually "+i+"!!!!");
                            }
                          }*/
                          return geoJSONSortedBySvi[index].properties.countyName + ', ' + geoJSONSortedBySvi[index].properties.stateAbbrev;
                        }
                          //console.log(x,index,svi[index-1].RPL_THEMES);
                          //return geoJSON.features[index-1].properties.countyName + ', ' + svi[index-1].ST_ABBR;
                      },
                      name: function() { return; },
                      value: function() { return; }
                    }
                  },
                  legend: {
                      show: false
                  }
              });
              
              //scatterplot.legend.hide('yAxis');
              //scatterplot.legend.hide('yTrend');   
              //scatterplot.legend.hide('yHighlight');   
        }

        function createPieChart(cols){
          var piechart = c3.generate({
              bindto:'#pie-chart',
              data: {
                  columns: [
                      cols[0],
                      cols[1]
                  ],
                  type : 'pie'
              },
              color: {
                pattern: ['#8B74BD', '#B9BFFF']
              }
          });
        }

        function createDonutChart(cats){
          var donutchart = c3.generate({
              bindto:'#donut-chart',
              data: {
                  columns: [
                      cats[0],
                      cats[1],
                      cats[2],
                      cats[3],
                      cats[4]
                  ],
                  type : 'donut'
              },
              donut: {
                  title: "Mask Use"
              },
              color: {
                pattern: ['#ADEDFF', '#ACD0FC','#AAB1F8','#A892F4','#A573F0']
              }
          });
        }
        
        async function generateCharts(passedfips){
            matchFips = passedfips;
            //console.log(matchFips);
            
            if (currentSviLayer in sectionNames){
                document.getElementById('pie-chart').style.display = 'block';
                createPieChart(loadSections());
                document.getElementById('aws-pie-chart-title').innerHTML = sviVariables[ sectionNames[currentSviLayer][0] ].name;
                document.getElementById('aws-pie-chart-title').style.display = 'block';
            } else {
                document.getElementById('pie-chart').style.display = 'none';
                document.getElementById('aws-pie-chart-title').style.display = 'none';
            }
            
            createScatterplot(loadAxes());
            createDonutChart(loadMaskCats());
        }
        
        
        function createTrendAxis(x,y) {
          let axes = ['yTrend'];
          let results = leastSquares(x.slice(1),y.slice(1));
          let slope = results[0];
          let intercept = results[1];
          let trendLine = [intercept, slope + intercept];
          return axes.concat(trendLine);
        }
        
        
        // returns slope, intercept and r-square of the line
      	function leastSquares(xSeries, ySeries) {
      		let reduceSumFunc = function(prev, cur) { return prev + cur; };
      		
      		let xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
      		let yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;
      
      		let ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
      			.reduce(reduceSumFunc);
      		
      		let ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
      			.reduce(reduceSumFunc);
      			
      		let ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
      			.reduce(reduceSumFunc);
      			
      		let slope = ssXY / ssXX;
      		let intercept = yBar - (xBar * slope);
      		let rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);
      		
      		return [slope, intercept, rSquare];
      	}